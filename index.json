[{"categories":["数据库"],"content":"Doris 0.15.1升级至1.1.1版本操作说明 ","date":"2022-11-02","objectID":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/:0:0","tags":["Doris","中间件","数据库"],"title":"Doris 0.15.1升级至1.1.1版本操作说明","uri":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/"},{"categories":["数据库"],"content":"一、环境信息 名称 ip 备注/其他 Doris-de01 172.31.24.184 Doris-de02 172.31.16.119 Doris-de03 172.31.30.174 Doris-de04 172.31.23.38 Doris-de05 172.31.22.228 Doris-de06 172.31.45.123 Doris-de07 172.31.43.42 Doris-fe01 172.31.21.232 IsMaster Doris-fe02 172.31.17.196 Doris-fe03 172.31.17.204 OBSERVER Doris-fe04 172.31.11.169 ","date":"2022-11-02","objectID":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/:1:0","tags":["Doris","中间件","数据库"],"title":"Doris 0.15.1升级至1.1.1版本操作说明","uri":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/"},{"categories":["数据库"],"content":"二、具体操作步骤及说明 ","date":"2022-11-02","objectID":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/:2:0","tags":["Doris","中间件","数据库"],"title":"Doris 0.15.1升级至1.1.1版本操作说明","uri":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/"},{"categories":["数据库"],"content":"前置工作 关闭集群副本修复和均衡功能 升级过程中会有节点重启，所以可能会触发不必要的集群均衡和副本修复逻辑。可以先通过以下命令关闭： 优先查看下集群默认参数： ![image-20220825170322568](/Users/zhangdawei/Library/Application Support/typora-user-images/image-20220825170322568.png) # 关闭副本均衡逻辑。关闭后，不会再触发普通表副本的均衡操作。 $ mysql-client \u003e admin set frontend config(\"disable_balance\" = \"true\"); # 关闭 colocation 表的副本均衡逻辑。关闭后，不会再触发 colocation 表的副本重分布操作。 $ mysql-client \u003e admin set frontend config(\"disable_colocate_balance\" = \"true\"); # 关闭副本调度逻辑。关闭后，所有已产生的副本修复和均衡任务不会再被调度。 $ mysql-client \u003e admin set frontend config(\"disable_tablet_scheduler\" = \"true\"); ==当集群升级完毕后，在通过以上命令将对应配置设为原值即可。== 重要！！在升级之前需要备份元数据（整个目录都需要备份）！！ 所有fe机器/data/doris-meta数据目录备份。 tar -zcvf /data/doris-meta.tar.gz /data/doris-meta cp -R /data/doris-meta /data/doris-meta-0.15.1-date 官网下载二进制文件，进行配置 wget https://archive.apache.org/dist/doris/1.1/1.1.1-rc03/apache-doris-1.1.1-bin-x86.tar.gz tar -zxvf apache-doris-1.1.1-bin-x86.tar.gz mv apache-doris-1.1.1-bin-x86 /opt/doris-1.1.1 cd /opt/doris-1.1.1 ","date":"2022-11-02","objectID":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/:2:1","tags":["Doris","中间件","数据库"],"title":"Doris 0.15.1升级至1.1.1版本操作说明","uri":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/"},{"categories":["数据库"],"content":"测试 BE 升级正确性 任意选择一个 BE 节点，部署最新的 doris_be 二进制文件。 1.1、doris07节点测试,==（具体路径已线上正式环境目录路径为准。）== sh /opt/doris-be-0.15.1/bin/stop_be.sh cd /opt/doris-be-0.15.1/ mv lib lib-0.15.1-$date cp -R /opt/doris-1.1.1/be/lib ./ sh /opt/doris-be-0.15.1/bin/start_be.sh --daemon #查看日志启动是否正常,具体路径已线上正式环境目录路径为准。 重启 BE 节点，通过 BE 日志 be.INFO，查看是否启动成功。 如果启动失败，可以先排查原因。如果错误不可恢复，可以直接通过 DROP BACKEND 删除该 BE、清理数据后，使用上一个版本的 doris_be 重新启动 BE。然后重新 ADD BACKEND。（该方法会导致丢失一个数据副本，请务必确保3副本完整的情况下，执行这个操作！！！） ","date":"2022-11-02","objectID":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/:2:2","tags":["Doris","中间件","数据库"],"title":"Doris 0.15.1升级至1.1.1版本操作说明","uri":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/"},{"categories":["数据库"],"content":"测试 FE 元数据兼容性 重要！!元数据兼容性异常很可能导致数据无法恢复！！ 单独使用新版本部署一个测试用的 FE 进程（建议在自己本地的开发机，或者BE节点。如果在Follower或者Observer节点上，需要停止启动的进程,但是不建议在Follower或者Observer节点上测试）。 2.1、还是在be07节点上copy一份fe节点的部署包、及/data/doris-meta 修改相关配置进行兼容性启动测试。 2.2、be07节点测试fe升级兼容性==（具体路径已线上正式环境目录路径为准。）== sh /opt/doris-fe-0.15.1/bin/stop_be.sh cd /opt/doris-fe-0.15.1/ mv lib lib-0.15.1-date cp -R /opt/doris-1.1.1/fe/lib ./ vim /opt/doris-fe-0.15.1/conf/fe.conf cp /home/quicksuper/doris-meta.tar.gz /data/ \u0026\u0026 cd /data \u0026\u0026 tar -zxvf doris-meta.tar.gz vim /data/doris-meta/image/VERSION #操作完3-7步骤后最后在执行步骤8 sh /opt/doris-fe-0.15.1/bin/start_be.sh --daemon #查看日志启动是否正常,具体路径已线上正式环境目录路径为准。 修改测试用的 FE 的配置文件 fe.conf，将所有端口设置为与线上不同。 在 fe.conf 添加配置：cluster_id=123456 在 fe.conf 添加配置：metadata_failure_recovery=true 拷贝线上环境 Master FE 的元数据目录 doris-meta 到测试环境 将拷贝到测试环境中的 doris-meta/image/VERSION 文件中的 cluster_id 修改为 123456（即与第3步中相同） 在测试环境中，运行 sh bin/start_fe.sh 启动 FE 通过 FE 日志 fe.log 观察是否启动成功。 如果启动成功，运行 sh bin/stop_fe.sh 停止测试环境的 FE 进程。 以上 2-6 步的目的是防止测试环境的FE启动后，错误连接到线上环境中。 ","date":"2022-11-02","objectID":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/:2:3","tags":["Doris","中间件","数据库"],"title":"Doris 0.15.1升级至1.1.1版本操作说明","uri":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/"},{"categories":["数据库"],"content":"三、滚动升级 确认新版本的文件部署完成后。逐台重启 FE 和 BE 实例即可。 建议逐台重启 BE 后，再逐台重启 FE。因为通常 Doris 保证 FE 到 BE 的向后兼容性，即老版本的 FE 可以访问新版本的 BE。但可能不支持老版本的 BE 访问新版本的 FE。 建议确认前一个实例启动成功后，再重启下一个实例。实例启动成功的标识，请参阅安装部署文档。 https://doris.incubator.apache.org/zh-CN/docs/install/install-deploy/ 常见问题–进程相关 ","date":"2022-11-02","objectID":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/:3:0","tags":["Doris","中间件","数据库"],"title":"Doris 0.15.1升级至1.1.1版本操作说明","uri":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/"},{"categories":["数据库"],"content":"关于版本回滚 因为数据库是一个有状态的服务，所以在大多数情况下，Doris 无法支持版本回滚（版本降级）。在某些情况下，可以支持 3 位或 4 位版本的回滚，但不会支持 2 位版本的回滚。 所以建议通过先升级部分节点并观察业务运行情况的方式（灰度升级）来降低升级风险。 非法的回滚操作可能导致数据丢失和损坏。 建议回滚时，保留最初备份文件及tar文件放置源数据丢失。 1、先回滚fe，所有机器全部执行完回滚操作在进行重启动作**==(文件名、文件路径根据线上环境进行修改)==**；因回滚了doris-meta，可能会有升级期间的数据丢失。 # 关闭副本均衡逻辑。关闭后，不会再触发普通表副本的均衡操作。 $ mysql-client \u003e admin set frontend config(\"disable_balance\" = \"true\"); # 关闭 colocation 表的副本均衡逻辑。关闭后，不会再触发 colocation 表的副本重分布操作。 $ mysql-client \u003e admin set frontend config(\"disable_colocate_balance\" = \"true\"); # 关闭副本调度逻辑。关闭后，所有已产生的副本修复和均衡任务不会再被调度。 $ mysql-client \u003e admin set frontend config(\"disable_tablet_scheduler\" = \"true\"); cd /opt/doris-fe-0.15.1 mv lib lib-date-1.1.1 cp -R lib-0.15.1-date lib cd /data mv doris-meta doris-meta-1.1.1-date cp -R doris-meta-0.15.1-date doris-meta sh /opt/doris-fe-0.15.1/bin/stop_fe.sh sh /opt/doris-fe-0.15.1/bin/start_fe.sh --daemon 2、检查进程启动及日志。 ![l2p3OXWDqd](/Users/zhangdawei/Library/Application Support/LarkShell/sdk_storage/242809214bfd58425e3f89823c700afd/resources/images/l2p3OXWDqd.jpg) 3、回滚be节点，与fe节点操作方式一致，所有机器全部执行完回滚操作在进行重启动作**==(文件名、文件路径根据线上环境进行修改)==** cd /opt/doris-be-0.15.1/ mv lib ./lib-0825-1.1.1-date cp -R lib-0.15.1-date lib sh /opt/be-0.15.1/bin/stop_be.sh sh /opt/be-0.15.1/bin/start_be.sh --daemon ![VnNCIDWKFE](/Users/zhangdawei/Library/Application Support/LarkShell/sdk_storage/242809214bfd58425e3f89823c700afd/resources/images/VnNCIDWKFE.jpg) 回滚后doris集群状态正常，但服务连接报错不可用，根据官方建议不建议回滚。 ","date":"2022-11-02","objectID":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/:4:0","tags":["Doris","中间件","数据库"],"title":"Doris 0.15.1升级至1.1.1版本操作说明","uri":"/doris-0.15.1%E5%8D%87%E7%BA%A7%E8%87%B31.1.1%E7%89%88%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8Ev1.2/"},{"categories":["容器"],"content":"容器生命周期管理 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:0","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker run 命令 docker run ： 创建一个新的容器并运行一个命令 语法 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=“nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=“ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=“0-2” or –cpuset=“0,1,2”: 绑定容器到指定CPU运行； -m : 设置容器使用内存最大值； –net=“bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 PS示例: 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。 docker run --name mynginx -d nginx:latest 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。 docker run -P -d nginx:latest 使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。 docker run -p 80:80 -v /data:/data -d nginx:latest 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。 $ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash 使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。 runoob@runoob:~$ docker run -it nginx:latest /bin/bash root@b8573233d675:/# node： 在 Docker 容器退出时，默认容器内部的文件系统仍然被保留，以方便调试并保留用户数据。 但是，对于 foreground 容器，由于其只是在开发调试过程中短期运行，其用户数据并无保留的必要，因而可以在容器启动时设置 –rm 选项，这样在容器退出时就能够自动清理容器内部的文件系统。 示例如下： docker run --rm ba-208 等价于： docker run --rm=true ba-208 显然，–rm 选项不能与 -d 同时使用（或者说同时使用没有意义），即只能自动清理 foreground 容器，不能自动清理detached容器。 注意，–rm 选项也会清理容器的匿名data volumes。 所以，执行 docker run 命令带 –rm命令选项，等价于在容器退出后，执行 docker rm -v ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:1","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker start/stop/restart 命令 docker start :启动一个或多个已经被停止的容器 docker stop :停止一个运行中的容器 docker restart :重启容器 语法 docker start [OPTIONS] CONTAINER [CONTAINER...] docker stop [OPTIONS] CONTAINER [CONTAINER...] docker restart [OPTIONS] CONTAINER [CONTAINER...] PS示例： 启动已被停止的容器myrunoob docker start myrunoob 停止运行中的容器myrunoob docker stop myrunoob 重启容器myrunoob docker restart myrunoob ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:2","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker kill 命令 docker kill :杀掉一个运行中的容器。 语法 docker kill [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明： -s : 向容器发送一个信号 PS示例： 杀掉运行中的容器mynginx runoob@runoob:~$ docker kill -s KILL mynginx mynginx ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:3","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker rm 命令 docker rm ： 删除一个或多个容器。 语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明： -f : 通过 SIGKILL 信号强制删除一个运行中的容器。 -l : 移除容器间的网络连接，而非容器本身。 -v : 删除与容器关联的卷。 PS示例 强制删除容器 db01、db02： docker rm -f db01 db02 移除容器 nginx01 对容器 db01 的连接，连接名 db： docker rm -l db 删除容器 nginx01, 并删除容器挂载的数据卷： docker rm -v nginx01 删除所有已经停止的容器： docker rm $(docker ps -a -q) ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:4","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker pause/unpause 命令 docker pause :暂停容器中所有的进程。 docker unpause :恢复容器中所有的进程。 语法 docker pause CONTAINER [CONTAINER...] docker unpause CONTAINER [CONTAINER...] PS示例 暂停数据库容器db01提供服务。 docker pause db01 恢复数据库容器 db01 提供服务。 docker unpause db01 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:5","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker create 命令 docker create ： 创建一个新的容器但不启动它 用法同 [docker run](#docker run 命令) 语法 docker create [OPTIONS] IMAGE [COMMAND] [ARG...] 语法同 [docker run](#docker run 命令) PS示例 使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob runoob@runoob:~$ docker create --name myrunoob nginx:latest 09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:6","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker exec 命令 docker exec ： 在运行的容器中执行命令 语法 docker exec [OPTIONS] CONTAINER COMMAND [ARG...] OPTIONS说明： -d : 分离模式: 在后台运行 -i : 即使没有附加也保持STDIN 打开 -t : 分配一个伪终端 PS示例 在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本: runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.sh http://www.runoob.com/ 在容器 mynginx 中开启一个交互模式的终端: runoob@runoob:~$ docker exec -i -t mynginx /bin/bash root@b1a0703e41e7:/# 也可以通过 docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。 查看已经在运行的容器 ID： # docker ps -a ... 9df70f9a0714 openjdk \"/usercode/script.sh…\" ... 第一列的 9df70f9a0714 就是容器 ID。 通过 exec 命令对指定的容器执行 bash: # docker exec -it 9df70f9a0714 /bin/bash ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:1:7","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"容器操作 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:0","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker ps 命令： docker ps : 列出容器 语法 docker ps [OPTIONS] OPTIONS说明： -a : 显示所有的容器，包括未运行的。 -f : 根据条件过滤显示的内容。 –format : 指定返回值的模板文件。 -l : 显示最近创建的容器。 -n : 列出最近创建的n个容器。 –no-trunc : 不截断输出。 -q : 静默模式，只显示容器编号。 -s : 显示总的文件大小。 PS示例 列出所有在运行的容器信息。 runoob@runoob:~$ docker ps CONTAINER ID IMAGE COMMAND ... PORTS NAMES 09b93464c2f7 nginx:latest \"nginx -g 'daemon off\" ... 80/tcp, 443/tcp myrunoob 96f7f14e99ab mysql:5.6 \"docker-entrypoint.sh\" ... 0.0.0.0:3306-\u003e3306/tcp mymysql 输出详情介绍： CONTAINER ID: 容器 ID。 IMAGE: 使用的镜像。 COMMAND: 启动容器时运行的命令。 CREATED: 容器的创建时间。 STATUS: 容器状态。 状态有7种： created（已创建） restarting（重启中） running（运行中） removing（迁移中） paused（暂停） exited（停止） dead（死亡） PORTS: 容器的端口信息和使用的连接类型（tcp\\udp）。 NAMES: 自动分配的容器名称。 列出最近创建的5个容器信息。 runoob@runoob:~$ docker ps -n 5 CONTAINER ID IMAGE COMMAND CREATED 09b93464c2f7 nginx:latest \"nginx -g 'daemon off\" 2 days ago ... b8573233d675 nginx:latest \"/bin/bash\" 2 days ago ... b1a0703e41e7 nginx:latest \"nginx -g 'daemon off\" 2 days ago ... f46fb1dec520 5c6e1090e771 \"/bin/sh -c 'set -x \\t\" 2 days ago ... a63b4a5597de 860c279d2fec \"bash\" 2 days ago ... 列出所有创建的容器ID。 runoob@runoob:~$ docker ps -a -q 09b93464c2f7 b8573233d675 b1a0703e41e7 f46fb1dec520 a63b4a5597de 6a4aa42e947b de7bb36e7968 43a432b73776 664a8ab1a585 ba52eb632bbd ... ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:1","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker inspect 命令： docker inspect : 获取容器/镜像的元数据。 语法 docker inspect [OPTIONS] NAME|ID [NAME|ID...] OPTIONS说明： -f : 指定返回值的模板文件。 -s : 显示总的文件大小。 –type : 为指定类型返回JSON。 PS示例 获取镜像mysql:5.6的元信息。 runoob@runoob:~$ docker inspect mysql:5.6 [ { \"Id\": \"sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec\", \"RepoTags\": [ \"mysql:5.6\" ], \"RepoDigests\": [], \"Parent\": \"\", \"Comment\": \"\", \"Created\": \"2016-05-24T04:01:41.168371815Z\", \"Container\": \"e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54\", \"ContainerConfig\": { \"Hostname\": \"b0cf605c7757\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": false, \"AttachStdout\": false, \"AttachStderr\": false, \"ExposedPorts\": { \"3306/tcp\": {} }, ... 获取正在运行的容器mymysql的 IP。 runoob@runoob:~$ docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mymysql 172.17.0.3 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:2","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker top 命令 docker top : 查看容器中运行的进程信息，支持 ps 命令参数。 语法 docker top [OPTIONS] CONTAINER [ps OPTIONS] 容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。 PS示例 查看容器mymysql的进程信息。 runoob@runoob:~/mysql$ docker top mymysql UID PID PPID C STIME TTY TIME CMD 999 40347 40331 18 00:58 ? 00:00:02 mysqld 查看所有运行容器的进程信息。 for i in `docker ps |grep Up|awk '{print $1}'`;do echo \\ \u0026\u0026docker top $i; done ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:3","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker attach 命令 docker attach : 连接到正在运行中的容器。 语法 docker attach [OPTIONS] CONTAINER 要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。 官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。 PS示例 容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。 runoob@runoob:~$ docker attach --sig-proxy=false mynginx 192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] \"GET / HTTP/1.1\" 304 0 \"-\" \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36\" \"-\" ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:4","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker events 命令 docker events : 从服务器获取实时事件 语法 docker events [OPTIONS] OPTIONS说明： -f ： 根据条件过滤事件； –since ： 从指定的时间戳后显示所有事件; –until ： 流水时间显示到指定的时间为止； PS示例 显示docker 2016年7月1日后的所有事件。 runoob@runoob:~/mysql$ docker events --since=\"1467302400\" 2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge) 2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani) 2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167) 2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani) ... 显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。 runoob@runoob:~/mysql$ docker events -f \"image\"=\"mysql:5.6\" --since=\"1467302400\" 2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql) 2016-07-11T00:51:17.022572452+08:00 container kill 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9) 2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql) 2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql) 2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql) 2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=“2016-07-01”。 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:5","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker logs 命令 docker logs : 获取容器的日志 语法 docker logs [OPTIONS] CONTAINER OPTIONS说明： -f : 跟踪日志输出 –since : 显示某个开始时间的所有日志 -t : 显示时间戳 –tail : 仅列出最新N条容器日志 PS示例 跟踪查看容器mynginx的日志输出。 runoob@runoob:~$ docker logs -f mynginx 192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] \"GET / HTTP/1.1\" 200 612 \"-\" \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36\" \"-\" 2016/07/10 16:53:33 [error] 5#5: *1 open() \"/usr/share/nginx/html/favicon.ico\" failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: \"GET /favicon.ico HTTP/1.1\", host: \"192.168.239.130\", referrer: \"http://192.168.239.130/\" 192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] \"GET /favicon.ico HTTP/1.1\" 404 571 \"http://192.168.239.130/\" \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36\" \"-\" 192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] \"GET / HTTP/1.1\" 304 0 \"-\" \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36\" \"-\" ... 查看容器mynginx从2016年7月1日后的最新10条日志。 docker logs --since=\"2016-07-01\" --tail=10 mynginx ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:6","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker wait 命令 docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。 语法 docker wait [OPTIONS] CONTAINER [CONTAINER...] PS示例 docker wait CONTAINER ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:7","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker export 命令 docker export : 将文件系统作为一个tar归档文件导出到STDOUT。 语法 docker export [OPTIONS] CONTAINER OPTIONS说明： -o : 将输入内容写到文件。 PS示例 将id为a404c6c174a2的容器按日期保存为tar文件。 runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2 runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar mysql-20160711.tar ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:8","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker port 命令 docker port : 列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。 语法 docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]] PS示例 查看容器mynginx的端口映射情况。 runoob@runoob:~$ docker port mymysql 3306/tcp -\u003e 0.0.0.0:3306 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:2:9","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"容器rootfs命令 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:0","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker commit命令 docker commit : 从容器创建一个新的镜像。 语法 docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] OPTIONS说明： -a : 提交的镜像作者； -c : 使用Dockerfile指令来创建镜像； -m : 提交时的说明文字； -p : 在commit时，将容器暂停。 PS示例 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。 runoob@runoob:~$ docker commit -a \"runoob.com\" -m \"my apache\" a404c6c174a2 mymysql:v1 sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057 runoob@runoob:~$ docker images mymysql:v1 REPOSITORY TAG IMAGE ID CREATED SIZE mymysql v1 37af1236adef 15 seconds ago 329 MB ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:1","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker cp命令 docker cp : 用于容器与主机之间的数据拷贝。 语法 docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH OPTIONS说明： -L : 保持源目标中的链接 PS示例 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。 docker cp /www/runoob 96f7f14e99ab:/www/ 将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。 docker cp /www/runoob 96f7f14e99ab:/www 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。 docker cp 96f7f14e99ab:/www /tmp/ ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:2","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker diff命令 docker diff : 检查容器里文件结构的更改。 语法 docker diff [OPTIONS] CONTAINER PS示例 查看容器mymysql的文件结构更改。 runoob@runoob:~$ docker diff mymysql A /logs A /mysql_data C /run C /run/mysqld A /run/mysqld/mysqld.pid A /run/mysqld/mysqld.sock C /tmp ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:3:3","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"镜像仓库 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:4:0","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker login/logout命令 docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub 语法 docker login [OPTIONS] [SERVER] docker logout [OPTIONS] [SERVER] OPTIONS说明： -u : 登陆的用户名 -p : 登陆的密码 PS示例 登陆到Docker Hub docker login -u 用户名 -p 密码 登出Docker Hub docker logout ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:4:1","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker pull命令 docker pull : 从镜像仓库中拉取或者更新指定镜像 语法 docker pull [OPTIONS] NAME[:TAG|@DIGEST] OPTIONS说明： -a : 拉取所有 tagged 镜像 –disable-content-trust : 忽略镜像的校验,默认开启 PS示例 从Docker Hub下载java最新版镜像。 docker pull java 从Docker Hub下载REPOSITORY为java的所有镜像。 docker pull -a java ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:4:2","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker push 命令 docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库 语法 docker push [OPTIONS] NAME[:TAG] OPTIONS说明： –disable-content-trust : 忽略镜像的校验,默认开启 PS示例 上传本地镜像myapache:v1到镜像仓库中。 docker push myapache:v1 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:4:3","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker search命令 docker search : 从Docker Hub查找镜像 语法 docker search [OPTIONS] TERM OPTIONS说明： –automated : 只列出 automated build类型的镜像； –no-trunc : 显示完整的镜像描述； -f \u003c过滤条件\u003e: 列出收藏数不小于指定值的镜像。 PS示例 从 Docker Hub 查找所有镜像名包含 java，并且收藏数大于 10 的镜像 runoob@runoob:~$ docker search -f stars=10 java NAME DESCRIPTION STARS OFFICIAL AUTOMATED java Java is a concurrent, class-based... 1037 [OK] anapsix/alpine-java Oracle Java 8 (and 7) with GLIBC ... 115 [OK] develar/java 46 [OK] isuper/java-oracle This repository contains all java... 38 [OK] lwieske/java-8 Oracle Java 8 Container - Full + ... 27 [OK] nimmis/java-centos This is docker images of CentOS 7... 13 [OK] 参数说明： NAME: 镜像仓库源的名称 DESCRIPTION: 镜像的描述 OFFICIAL: 是否 docker 官方发布 stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。 AUTOMATED: 自动构建。 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:4:4","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"本地镜像管理 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:0","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker images命令 docker images : 列出本地镜像。 语法 docker images [OPTIONS] [REPOSITORY[:TAG]] OPTIONS说明： -a : 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）； –digests : 显示镜像的摘要信息； -f : 显示满足条件的镜像； –format : 指定返回值的模板文件； –no-trunc : 显示完整的镜像信息； -q : 只显示镜像ID。 PS示例 查看本地镜像列表。 runoob@runoob:~$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mymysql v1 37af1236adef 5 minutes ago 329 MB runoob/ubuntu v4 1c06aa18edee 2 days ago 142.1 MB \u003cnone\u003e \u003cnone\u003e 5c6e1090e771 2 days ago 165.9 MB httpd latest ed38aaffef30 11 days ago 195.1 MB alpine latest 4e38e38c8ce0 2 weeks ago 4.799 MB mongo 3.2 282fd552add6 3 weeks ago 336.1 MB redis latest 4465e4bcad80 3 weeks ago 185.7 MB php 5.6-fpm 025041cd3aa5 3 weeks ago 456.3 MB python 3.5 045767ddf24a 3 weeks ago 684.1 MB ... 列出本地镜像中REPOSITORY为ubuntu的镜像列表。 root@runoob:~# docker images ubuntu REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 14.04 90d5884b1ee0 9 weeks ago 188 MB ubuntu 15.10 4e3b13c8a266 3 months ago 136.3 MB ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:1","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker rmi命令 docker rmi : 删除本地一个或多个镜像。 语法 docker rmi [OPTIONS] IMAGE [IMAGE...] OPTIONS说明： -f : 强制删除； –no-prune : 不移除该镜像的过程镜像，默认移除； PS示例 强制删除本地镜像 runoob/ubuntu:v4。 root@runoob:~# docker rmi -f runoob/ubuntu:v4 Untagged: runoob/ubuntu:v4 Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:2","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker tag命令 docker tag : 标记本地镜像，将其归入某一仓库。 语法 docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] PS示例 将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像。 root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3 root@runoob:~# docker images runoob/ubuntu:v3 REPOSITORY TAG IMAGE ID CREATED SIZE runoob/ubuntu v3 4e3b13c8a266 3 months ago 136.3 MB ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:3","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker build命令 docker build 命令用于使用 Dockerfile 创建镜像。 语法 docker build [OPTIONS] PATH | URL | - OPTIONS说明： –build-arg=[] : 设置镜像创建时的变量； –cpu-shares : 设置 cpu 使用权重； –cpu-period : 限制 CPU CFS周期； –cpu-quota : 限制 CPU CFS配额； –cpuset-cpus : 指定使用的CPU id； –cpuset-mems : 指定使用的内存 id； –disable-content-trust : 忽略校验，默认开启； -f : 指定要使用的Dockerfile路径； –force-rm : 设置镜像过程中删除中间容器； –isolation : 使用容器隔离技术； –label=[] : 设置镜像使用的元数据； -m : 设置内存最大值； –memory-swap : 设置Swap的最大值为内存+swap，\"-1\"表示不限swap； –no-cache : 创建镜像的过程不使用缓存； –pull : 尝试去更新镜像的新版本； –quiet, -q : 安静模式，成功后只输出镜像 ID； –rm : 设置镜像成功后删除中间容器； –shm-size : 设置/dev/shm的大小，默认值是64M； –ulimit : Ulimit配置。 –squash : 将 Dockerfile 中所有的操作压缩为一层。 –tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 –network: 默认 default。在构建期间设置RUN指令的网络模式 PS示例 使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。 docker build -t runoob/ubuntu:v1 . 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。 docker build github.com/creack/docker-firefox 也可以通过 -f Dockerfile 文件的位置： $ docker build -f /path/to/a/Dockerfile . 在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回： $ docker build -t test/myapp . Sending build context to Docker daemon 2.048 kB Error response from daemon: Unknown instruction: RUNCMD ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:4","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker history命令 docker history : 查看指定镜像的创建历史。 语法 docker history [OPTIONS] IMAGE OPTIONS说明： -H : 以可读的格式打印镜像大小和日期，默认为true； –no-trunc : 显示完整的提交记录； -q : 仅列出提交记录ID。 PS示例 查看本地镜像runoob/ubuntu:v3的创建历史。 root@runoob:~# docker history runoob/ubuntu:v3 IMAGE CREATED CREATED BY SIZE COMMENT 4e3b13c8a266 3 months ago /bin/sh -c #(nop) CMD [\"/bin/bash\"] 0 B \u003cmissing\u003e 3 months ago /bin/sh -c sed -i 's/^#\\s*\\(deb.*universe\\)$/ 1.863 kB \u003cmissing\u003e 3 months ago /bin/sh -c set -xe \u0026\u0026 echo '#!/bin/sh' \u003e /u 701 B \u003cmissing\u003e 3 months ago /bin/sh -c #(nop) ADD file:43cb048516c6b80f22 136.3 MB ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:5","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker save命令 docker save : 将指定镜像保存成 tar 归档文件。 语法 docker save [OPTIONS] IMAGE [IMAGE...] OPTIONS 说明： -o : 输出到的文件。 PS示例 将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档 runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3 runoob@runoob:~$ ll my_ubuntu_v3.tar -rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:6","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker load 命令 docker load : 导入使用 docker save 命令导出的镜像。 语法 docker load [OPTIONS] OPTIONS 说明： –input , -i : 指定导入的文件，代替 STDIN。 –quiet , -q : 精简输出信息。 PS示例 导入镜像： $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE $ docker load \u003c busybox.tar.gz Loaded image: busybox:latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 769b9341d937 7 weeks ago 2.489 MB $ docker load --input fedora.tar Loaded image: fedora:rawhide Loaded image: fedora:20 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 769b9341d937 7 weeks ago 2.489 MB fedora rawhide 0d20aec6529d 7 weeks ago 387 MB fedora 20 58394af37342 7 weeks ago 385.5 MB fedora heisenbug 58394af37342 7 weeks ago 385.5 MB fedora latest 58394af37342 7 weeks ago 385.5 MB ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:7","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker import 命令 docker import : 从归档文件中创建镜像。 语法 docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] OPTIONS说明： -c : 应用docker 指令创建镜像； -m : 提交时的说明文字； PS示例 从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4 runoob@runoob:~$ docker import my_ubuntu_v3.tar runoob/ubuntu:v4 sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39 runoob@runoob:~$ docker images runoob/ubuntu:v4 REPOSITORY TAG IMAGE ID CREATED SIZE runoob/ubuntu v4 63ce4a6d6bc3 20 seconds ago 142.1 MB ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:5:8","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"info|version ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:6:0","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker info命令 docker info : 显示 Docker 系统信息，包括镜像和容器数。。 语法 docker info [OPTIONS] PS示例 查看docker系统信息。 $ docker info Containers: 12 Images: 41 Storage Driver: aufs Root Dir: /var/lib/docker/aufs Backing Filesystem: extfs Dirs: 66 Dirperm1 Supported: false Execution Driver: native-0.2 Logging Driver: json-file Kernel Version: 3.13.0-32-generic Operating System: Ubuntu 14.04.1 LTS CPUs: 1 Total Memory: 1.954 GiB Name: iZ23mtq8bs1Z ID: M5N4:K6WN:PUNC:73ZN:AONJ:AUHL:KSYH:2JPI:CH3K:O4MK:6OCX:5OYW ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:6:1","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["容器"],"content":"docker version命令 docker version : 显示 Docker 版本信息。 语法 docker version [OPTIONS] OPTIONS说明： -f : 指定返回值的模板文件。 PS示例 显示 Docker 版本信息。 $ docker version Client: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64 Server: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64 ","date":"2021-11-14","objectID":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:6:2","tags":["容器","docker","工具","搬运"],"title":"Docker命令大全","uri":"/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"categories":["通话"],"content":"Asterisk拨号规则 ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:0:0","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"一、前言 本文档以asterisk-1.4.32为基础写作而成，可能和其他版本有些区别。其中参考了一些别的书籍和文章。因为写的比较仓促，而且基本都是晚上写的，里面的内容逻辑性和语句没有仔细斟酌，就是想到什么写什么，难免有什么遗漏和错误的地方，大家发现请及时通知我修改。另外这是我第一次写技术性的文章还很嫩涩，算是一个开始，希望大家多多支持。 ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:1:0","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"二、Asterisk dialplan 基本结构 Asterisk dialplan 的语法可以分为四个关键点，也就是语法结构的四个组成部分，四个部分分别context ，extensionnum ，priority 和 action。由这四个组成部分dialplan的结构为： [context] exten =\u003e extensionnum,priority,action ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:2:0","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"1、context context是指dialplan的流程块，整个dialplan就是由每个context的内容组成，他们协作完成整个asterisk命令逻辑的运转。context的名字必须放在中括号之中，比如PSTN外线打进系统所执行的流程我们都习惯叫from-pstn，在语法里面就写做\"[from-pstn]\"。所有属于这个流程的内容都写在这个下面。每一个命令都由换行符来隔开，也就是说每一行就是一个命令，每一行命令都必须由\"exten =\u003e “（这个里面的空格可以没有）开头。流程的结尾就是遇到到下一个流程标识截止。 ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:2:1","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"2、extensionnum extensionnum是指流程块里面的流程匹配标识（也就是asterisk里面说的extension），这个匹配标识其实通常就是我们要拨的号码（当然这个匹配标识不光是数字也可以是字母或者一些特殊字符）。比如你拨分机101，而你设置的拨分机的流程块是dial-ext，那么asterisk就会在dial-ext流程块里面寻找能匹配101的流程，找到了就会执行。说到匹配大家就会想到通配符吧，哈哈，asterisk里面也有类似的通配符，下面我就介绍一下asterisk里面关于extension的通配符。 X和x表示单个0-9的数字 N和n表示单个1-9的数字 Z和z表示单个2-9的数字 .表示单个的任何字符和数字 []中括号里面可以是你想任意的匹配的数字或者字母，比如你想匹配1、3或者6，那么你就可以这样[136]或者[1,3,6]，在中括号里面还支持这样[1-8]是指匹配1到8的任意一个数字。 当你的extensionnum中含有任何通配符的时候你就要用一个短的下划线\"_\"来作为extensionnum的开头除了这些以外asterisk还有一些特殊意义的匹配字符， s ：是指Start extension，也就是当没有extension的时候就会执行这个流程（例如在模拟外线进线没有收到callerID的情况下就会转到这个extension来执行），另外在zapata.conf的channels段里面如果设定了immediate=yes程序就会自动找到s这流程来执行。 t ：是指timeout extension，也就是说如果等待用户输入超时后就会转到t这个流程来执行，在这里你可以设置一些提示音来告诉客户超时了。 i ：是指invalid extension，也就是说如果客户输入无效的时候会转到i这个流程来执行 fax ：是指fax calls，也就是说如果asterisk检测到传真信号的时候就会自动转到这个流程里面来执行。 h ：是指hangup extension，就是说呼叫终止后执行的流程，在这里通道已经终止，放音、发送DTMF等命令都不可用了，只能做一些呼叫结束后处理的一些工作。 需要注意的是，不管你设置的流程是什么都是属于某个流程块的，在不相互包含的情况下，流程块与流程块之间是相互独立的，流程或者变量是不会冲突的。 ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:2:2","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"3、priority priority是指流程里面的命令的执行优先级，除了跳转的情况，都是按照priority值的之从小到大执行的。在流程里面你会经常看见\"n\"这个priority，它是指next也就是上一个priority+1.我们通常还会给某个priority取个名字，来方便我们流程跳转，也方便流程的阅读。语法是这样的 exten =\u003e extensionnum,priority(name),action ，name就是这个priority的名字。 exten =\u003e _123409XX,1,GotoIf($[${EXTEN}=12340910]?ivr1:normal) exten =\u003e _123409XX,n(normal),Dial(SIP/101) exten =\u003e _123409XX,n,Goto(end) exten =\u003e _123409XX,n(ivr1),BackGround(MyVox/Greeting) exten =\u003e _123409XX,n(end),Hangup 上面这段代码就是当匹配的号码是12340901时就跳转到ivr1这个priority上否则就跳转到normal这个priority上。上面这段流程也可以写成： exten =\u003e _123409XX,1,GotoIf($[${EXTEN}=12340910]?4:2) exten =\u003e _123409XX,2,Dial(SIP/101) exten =\u003e _123409XX,3,Goto(5) exten =\u003e _123409XX,4,BackGround(MyVox/Greeting) exten =\u003e _123409XX,5,Hangup ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:2:3","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"4、action action就相对好理解多了就是流程里面你要执行的命令，asterisk支持的命令很多，我就介绍几个比较常用的。所有命令的规则里中括号里面是可选的部分，没有中括号的必须填加的。参数之间的分隔符是”|\",其实\",“来分隔也可以，但是1.6版本的asterisk不行，1.6的只能用”|\"。还应该注意的是action的命令名有大小写之分，写错将会出现错误，当命令没有参数时可以不用写小括号。 1)、Answer 语法： Answer([delay]) 应答一个振铃的Channel。如果呼叫没有被应答此方法将应答这个呼叫，如果delay这个参数指定那么应答成功后将等待delay秒后再返回执行下条命令，应答不成功就会直接返回错误返回值而不执行delay延迟。这个命令用于呼入的情况，呼出的时候不会真正执行answer操作但是会执行delay延迟。 2)、Playback 语法： Playback(filename[\u0026filename2...][|option]) 给当前Channel播放语音文件。第一个参数是语音文件，语音文件的格式asterisk默认的是gsm，其他wav、sln、vox、pcm等也都支持，但是最好用gsm格式的文件，如果没有gsm格式的可以用sox这个工具把格式变为gsm的，一般变成gsm格式的语音播放起来就不会有什么问题了。 播放的语音文件也可以是多个，每个之间用\"\u0026\"来分隔，语音文件的扩展名不用写，语音文件中不能有空格，最好就是字母和数字的组合，为了语义的需要可以用下划线来分隔。 当一个语音文件出现问题时命令就会停止，后面的语音文件就不会再被播放了。 语音文件是相对地址也可以是绝对地址，相对地址的默认路径是/var/lib/asterisk/sounds/。 第二个参数是一些控制变量，这个参数是可选的： skip ：如果这个变量设置，而且当前通道没有UP，命令就会立刻结束，不播放任何语音。 noanswer ：如果设置这个变量，在当前通道没有UP的时候，就不会执行anwser来UP这个通道。 say ：如果设置这个变量，在播放语音之前会把要播放的语音文件名都出来。 j ：如果设置这个变量，当语音文件播放出现问题的时候，流程就会跳转到priority+101这个priority继续执行。 通道变量PLAYBACKSTATUS，通道变量的值通常都是一个字符串，当语音播放成功后PLAYBACKSTATUS为SUCCESS，否则为FAILED。当播放多个文件时只要有一个文件播放失败PLAYBACKSTATUS即为FAILED。 3)、BackGround 语法： Background(filename1[\u0026filename2...][|options[|langoverride][|context]]) 给当前Channel播放语音文件，并等待客户输入，来执行相应的extension。第一个参数是语音文件，这个参数的用法跟Playbcak的第一参数用法一样。 第二个参数是一些控制变量，这个参数是可选的： s ：如果这个变量设置，而且当前通道没有UP，命令就会立刻结束，不播放任何语音。 n ：播放语音前不用answer这个通道 m ：只有当用户输入的能和参数context中的流程匹配才结束。 p ：只播放不接受用户输入。 第三个参数是指播放声音的语言，这个参数是可选的。 第四个参数是指当用户输入后要去寻找匹配并执行的context，在多层的IVR中这个参数是关键，这个参数是可选的。 4)、Dial 语法： Dial(Technology/resource[\u0026Tech2/resource2...][|timeout][|options][|URL]) 这个命令会是当前通道呼叫一个或多个Channel，其中有一个Channel应答，当前通道就会和这个Channel桥接在一起，其他Channel就会挂断。 第一个参数是要呼叫的通道可以是多个每个之间用\"\u0026\"来分隔。 第二个参数是超时时间，单位为秒，如果不设置超时时间，呼叫就会一直等到对方应答为止。 第三个参数是一些控制变量： A(x) ：当被叫方应答的时候给被叫方播放一段语音，x为要播放的语音文件 C ：重新设置CDR d ：允许主叫方在等待被叫方应答的时候，按一个数字键跳转到这个数字所能匹配的流程中，新的流程是指定在EXITCONTEXT变量中设置的流程，如果EXITCONTEXT没有被指定那么就在当前context中寻找。 D([called][:calling]) ：发送DTMF到主叫方或者被叫方，当被叫应答但是通道还没有桥接的时候。 f ：强制为被叫方Channel设置CallerID，用当前的extension g ：当对方挂机的后，接着当前的context执行 G(context^exten^pri) ：当呼叫被应答之后，将主叫方跳转到指定的priority中执行，被叫跳转到指定的priority+1中执行，指定的priority由G的参数指定。 h ：允许被叫方按\"*\"结束会话 H ：允许主叫方按\"*\"结束会话 i ：忽略任何forwarding请求 j ：当所有呼叫请求都忙的时候跳转到当前priority+101处 k ：允许被叫使用parking功能 K ：允许主叫使用parking功能 L(x[:y][:z]) ：限定呼叫'x'ms，当剩下'y'ms时播放一个警告，重复这个警告每隔'z'ms。下面这些变量是用于这个操作： LIMIT_PLAYAUDIO_CALLER yes|no (default yes) 对主叫播放语音 LIMIT_PLAYAUDIO_CALLEE yes|no 对被叫播放语音 LIMIT_TIMEOUT_FILE 时间到的时候播放的语音 LIMIT_CONNECT_FILE 呼叫开始时播放的语音 LIMIT_WARNING_FILE y定义的那个警告的语音，一般都是播放还剩多少时间 m([class]) ：为主叫提供hold music在Channel应答之前。 M(x[^arg]) ：为被叫Channel执行指定的宏，在还未和主叫桥接之前。被指定的参数可以用\"^\"来分隔。宏执行完后后会返回一个变量MACRO_RESULT来指示接下来要执行的命令： ABORT 通话两端都挂断 CONGESTION 当线路催挂的时候执行，也就是设置完CONGESTION状态，然后继续执行流程 BUSY 当线路忙的时候执行，如果j这个参数被设置则，跳转到priority+101处执行 CONTINUE 挂断被叫，主叫继续执行流程 GOTO:\u003ccontext\u003e^\u003cexten\u003e^\u003cpriority\u003e 跳转到指定的流程处继续执行 注意：TIMEOUT()函数不能用在宏中 n([x])和N ：修改screen/privacy模式. ；screen/privacy就是在被叫应答后还没有桥接之前给被叫播放一段IVR来让它做一些操作，其中就有选择是否愿意接受这个呼叫 p和P([x]) ：设置screen/privacy模式. o ：指定主叫Channel的callerID为被叫Channel的CallerID。 O([x]) ：设置Operator Services模式，只对zaptel和dahdi通道有效 r ：主叫等待应答是为主叫播放回铃音 S(x) ：应答后x秒挂断通话 t ：允许被叫发送DTMF实现transfer主叫 详细信息在features.conf中设置 T ：允许主叫发送DTMF实现transfer被叫 详细信息在features.conf中设置 w ：允许被叫发送DTMF为通话录音 详细信息在features.conf中设置 W ：允许主叫发送DTMF为通话录音 详细信息在features.conf中设置 第四个参数是一个url地址，如果通道支持这个url将发送给被叫 通道变量： DIALEDTIME 这个变量是指从呼叫开始到会话结束的时间 ANSWEREDTIME 这个变量是指应答开始到会话结束的时间 DIALSTATUS 这个变量显示的是呼叫的结果状态有以下一些值CHANUNAVAIL | CONGESTION | NOANSWER | BUSY | ANSWER | CANCEL | DONTCALL | TORTURE | INVALIDARGS ，在Privacy和Screening模式中，被叫选择发送主叫到'Go Away'脚本时状态变为DONTCALL；发送到'torture'脚本时状态变为TORTURE。 5)、Hangup 语法： Hangup([causecode]) 这个命令是挂断一个Channel。可选的参数是指定挂机的原因。 6)、Goto 语法： Goto([[context|]extension|]priority) 这个命令是跳转到指定priority处执行，默认是当前的context和extension。当输入的context直接挂机，当输入的extension和priority错误会在当前context寻找i流程来执行，如果i不存在就寻找h流程来执行，如果连h也不存在，就挂机。当没有任何参数的时候该通道也会挂机。 7)、GotoIf 语法： GotoIf(condition?[labeliftrue]:[labeliffalse]) 这个命令是有条件的跳转，跟c语言中的？：语句有点类似，当condition的条件为1时跳转到labeliftrue处，否则跳转到labeliffalse处。label的格式为[[context|","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:2:4","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"三、Dialplan中的变量和逻辑表达 ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:3:0","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"a、Dialplan中的变量通过${变量名}来引用和标识，变量名不一定要大些，但是大些可有助于阅读。 1)、全局变量 全局变量适用于所有的Context所有的extension。全局变量可以在[globals]段中定义，也可以通过SetGlobalVar()来定义。下面举个例子。 [globals] OUTLINE=Zap/g1 或 [from-ext] exten =\u003e _9XXXXXXX.,1,SetGlobalVar(OUTLINE=Zap/g1) 2)、通道变量 通道变量是特定的呼叫相关的变量，与全局变量不同，通道变量只能在当前呼叫存在期间定义，并只能用于参与该呼叫的通道。有很多预先定义的通道变来那个可以用于Dialplan，在asterisk源程序中的doc子目录下channelvariables.txt文件中有详细的介绍。通道变量可以通过Set()来设置。例如： exten =\u003e _123409XX,1,Set(INCOMING=${EXTEN}) EXTEN就是一个asterisk已经预先定义的变量，他表示的就是当前的extension。既然提到了EXTEN变量在这里顺便就说一下变量的截取，语法是这样的： {variable_name[:offset[:length]]}。举个例子俩说明一下： exten =\u003e 12340900,1,Set(INCOMING=${EXTEN}) 这个里面${EXTEN}就是12340900，如果我只想要后四位那怎么办那？${EXTEN:4}就表示0900了，也就是去掉了${EXTEN}的前四位；那要是想要前四位怎么办那？很简单${EXTEN:0:4}就表示1234了。offset和length也可以是负数，offset是负数表示要的是从后面数|offset|个数，length是负数表示要的是除了从后面数的|length|个数。哈哈，说的不太明白举个例子吧。${EXTEN:-4}也表示0900，${EXTEN:-2}就表示00，${EXTEN:2:4}表示3409，${EXTEN:2:-2}也表示3409，${EXTEN:-6:-2}也表示3409. 3)、环境变量 环境变量是一种在asterisk里面访问操作系统环境变量的一种方法。这些变量以${ENV(var)}的形式引用，其中var就是要引用的操作系统环境变量。 ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:3:1","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"b、逻辑表达式. 你应该没有忘记${var}表示变量，逻辑表达式和这个差不多$[expression].$[1 + 2]就表示1+2的结果3.中括号中运算符和变量之间最好用空格分开，否则可能会出现错误的结果。当然中括号里面可以是任意运算符。这些预算符包括： 1)、逻辑运算符 expr1 | expr2 当expr1为真，赋值为expr1的值，否则为expr2的值 expr1 \u0026 expr2 当expr1和expr2的值都为真时，赋值为expr1的值，否则赋值为0 expr1 {=, \u003e, \u003e=, \u003c, \u003c=, !=} expr2 如果自变量都是整数，将得到一个整数的比较结果；否则他们将得到字符串的结果，如果给定的关系是正确的，这个结果是1，否则就是0. ! expr1 取反，当expr1是NULL、0、一个空字符串、或者一个字符串\"0\"，返回1；否则返回0. 2)、数学运算符 expr1 {+, -, *, /, %} expr2 加减乘除余数 \\- expr1 取负 3)、正则表达式运算符 expr1 : expr2 这个运算符expr2匹配到expr1，expr2必须是个表达式，如果匹配成功，被匹配的表达式包括了至少一个正则表达式的字表达式，整个表达式对应返回(1 or \\1);另外，匹配操作符返回字符匹配上的数量。如果匹配失败，返回空值。其他情况返回0. expr1 =~ expr2 这个运算符和：很像，唯一区别就是这个可以不从字符串的开始匹配。 4)、三态运算符 expr1 ? expr2 : expr3 这个用法就不用说了，说说expr1的否的条件就行了，数字的话是0，字符串时\"\"(空串)。 ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:3:2","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"c、运算符优先级 1)、(,) 2)、!,- 3)、:,=~ 4)、*,/,% 5)、+,- 6)、=,!=,\u003c,\u003e,\u003c=,\u003e= 7)、|,\u0026 8)、?: ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:3:3","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"四、拨号方案函数 拨号方案函数可以增加更多功能到你的表达式中，你可以想象他们运行起来和操作符类似，但是更高级一些。 语法：FUNCTION_NAME(argument) 非常像变量，你可以引用函数名，但是你如果要引用函数的值，就要用美元\"$“放在前面，用花括号”{}“括起函数表达式。就像这样： ${FUNCTION_NAME(argument)} 函数也可以嵌套封装其他的函数，如下： ${FUNCTION_NAME(${FUNCTION_NAME(argument)})} 举个例子吧： exten =\u003e 123,1,Set(TEST=example) exten =\u003e 123,2,SayNumber(${LEN(${TEST})}) 上面这个例子能算出字符串example有7个字符，将字符串的数量赋值给变量长度，然后将数量送给SayNumber(). ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:4:0","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"五、Include Asterisk允许在一个context中使用另一个context，通过include指令来实现。这用来授予访问权给不同的拨号方案段。介绍一下语法： 语法：include =\u003e context 在当前context包含另外的context时，必须注意包含顺序。Asterisk首先试图在当前context中匹配extension。如果不成功，会试图尝试第一个包含进来的context，然后按照包含顺序再去尝试其他的context。就跟把包含的contex拷贝到当前context的后面有点类似。另外还有一种include的应用就是一个dialplan文件包含另一个dialplan文件，意思和上面说的include用法差不多，只不过这回是文件。 语法：#include FILENAME 这个在elastrix中应用的比较多，差不多每个关键的配置文件都包含另一个附加的配置文件。举个在elastrix里面的例子，在extensions.conf 文件中你会发现这样的语句： #include extensions_additional.conf #include extensions_custom.conf ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:5:0","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"六、宏macro 你如果熟悉计算机编程，那么你对宏就肯定不会陌生，dialplan也支持。你可以定义一个宏指令，它包含多步的指令列表，然后让电话extension指向这个宏指令。 语法：[macro-MACRONAME] exten =\u003e s,1,action exten =\u003e s,n,action exten =\u003e s,n,action 调用语法：exten =\u003e Macro(macroname,arg1,arg2...) 宏指令的名字必须以macro-作为开始。这是他们与常规的context的区别。Dialplan中的宏指令的命令同其他任何命令很相似。唯一的限制因素是宏指令只能用\"s\"extension。我们先定义一个宏指令： [macro-dial] exten =\u003e s,1,Dial(SIP/101) exten =\u003e s,n,VoiceMail(101) 接下来我们看看怎样调用宏指令： exten =\u003e _123409XX,1,GotoIf(\\$[\\${EXTEN}=12340910]?4:2) exten =\u003e _123409XX,2,Macro(dial) exten =\u003e _123409XX,3,Goto(5) exten =\u003e _123409XX,4,BackGround(MyVox/Greeting) exten =\u003e _123409XX,5,Hangup 此外Macro()程序也定义了几种特别的变量来为我们使用。它们包括: ${MACRO_CONTEXT} 这个被调用宏中，初始的context ${MACRO_EXTEN} 这个被调用宏中，初始的extension ${MACRO_PRIORITY} 这个被调用宏中，初始的priority ${MACRO_OFFSET} 宏返回后从${MACRO_OFFSET}+n+1的priority处执行 ${ARGn} 传递到宏指令的第n个变量。例如第一个自变量是${ARG1},第二个是${ARG2} 为了举个使用变量的例子，我们把上面例子的宏修改一下： [macro-dial] exten =\u003e s,1,Dial(SIP/1${MACRO_EXTEN:6}) exten =\u003e s,n,VoiceMail(1${MACRO_EXTEN:6}) 这样当拨的是12340901时宏就执行Dial(SIP/101),并给并留言到101语音信箱里面。 ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:6:0","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["通话"],"content":"七、结束语 终于结束了(有遗漏的以后再加吧)。其实这篇文章最初想法是写给杨兄的，后来想想既然写了为什么不写成个类似文章样式的，放到自己的空间，给一些希望了解asterisk的人一些帮助。 中文说asterisk的数很少，据我所和好像只有《asterisk未来电话之路》这本书汉化了，要想让技术发展就得有自由和宽松的风气，就像春秋战国时一样大家勇于发表自己的见解、勇于讨论。我知道国内有很多asterisk的高手,我搞asterisk也才只有两年，只能算个刚入门的新生，所以我希望能有更多的人，能把自己学到的对于asterisk技术见解和技术思路，都写出来大家分享。 哪怕就像我一样只是汇集翻译个文档。最后希望只要能帮助到大家就好，哈哈，记住转载一定要保留我的名字和出处，谢谢了。(附上作者连接在下方) 原文档连接：https://www.cnblogs.com/einyboy/archive/2012/10/17/2727792.html ","date":"2021-11-05","objectID":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/:7:0","tags":["通话","asterisk","工具"],"title":"Asterisk拨号规则","uri":"/asterisk%E6%8B%A8%E5%8F%B7%E8%A7%84%E5%88%99/"},{"categories":["数据库"],"content":"mongodb4.2 ARM平台编译 ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:0:0","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"1.Gcc和依赖软件下载 wget https://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2 wget https://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2 wget https://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz wget https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2 wget https://gcc.gnu.org/pub/gcc/releases/gcc-9.2.0/gcc-9.2.0.tar.gz ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:1:0","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"2.下载mongodb源码包 wget https://fastdl.mongodb.org/src/mongodb-src-r4.2.8.tar.gz 将1、2的软件包上传到/opt目录下 ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:2:0","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"3.安装gcc和依赖 ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:3:0","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"1）检查gcc版本 gcc -version ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:3:1","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"2）安装依赖 yum install -y bzip2 ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:3:2","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"3）上传gcc-9.2.0.tar.gz到/opt目录解压，将依赖包放入解压出来的gcc目录 cd /opt tar xf gcc-9.2.0.tar.gz cp isl-0.18.tar.bz2 mpc-1.0.3.tar.gz gmp-6.1.0.tar.bz2 mpfr-3.1.4.tar.bz2 gcc-9.2.0 cd gcc-9.2.0 ./contrib/download_prerequisites ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:3:3","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"4）执行编译安装 mkdir gcc-build-9.2.0 cd gcc-build-9.2.0 ../configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr make -j`cat /proc/cpuinfo| grep \"processor\"| wc -l` //8核大概需要40分钟 make install ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:3:4","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"5）查看gcc版本 gcc -version ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:3:5","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"4.安装系统依赖包 yum install libcurl-devel libyaml libyaml-devel python-setuptools zlib-devel libffi-devel openssl openssl-devel ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:4:0","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"5.安装python ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:5:0","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"1)升级Python至3.7版本。 Python3.7安装需要花费较长时间，请耐心等待。 yum install wget -y yum install -y zlib* openssl* cd /usr/local/src wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz tar -zxvf Python-3.7.0.tgz cd Python-3.7.0 mkdir /usr/local/python37 ./configure --prefix=/usr/local/python37 --enable-optimizations make -j8 \u0026\u0026 make install ps：如果出现上面的错误，再装一下依赖 yum install libffi-devel -y ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:5:1","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"2)设置Python3.7环境变量。 cp /usr/local/python37/bin/python3.7 /usr/bin mv /usr/bin/python3.7 /usr/bin/python3 mkdir /usr/local/lib/python3.7 cp /usr/local/python37/lib/* /usr/local/lib/python3.7/ -rf ldconfig ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:5:2","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"3)升级setuptools到新版本。 cd /usr/local/src/ wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-19.6.tar.gz tar -zxvf setuptools-19.6.tar.gz cd setuptools-19.6 python3 setup.py build python3 setup.py install ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:5:3","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"4)安装python模块 /usr/local/python37/bin/pip3 install psutil pyyaml cheetah3 ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:5:4","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"6.安装mongodb tar xf mongodb-src-r4.2.3.tar.gz -C /opt cd mongodb-src-r4.2.3 mkdir /usr/local/mongodb //指定安装路径--prefix=/usr/local/mongodb python3 buildscripts/scons.py --prefix=/usr/local/mongodb install MONGO_VERSION=4.2.3 core CFLAGS=\"-march=armv8-a+crc -mtune=generic\" -j8 --disable-warnings-as-errors //8C核大概40分钟 //删除调试信息，最后也可以将/home/mongodb/mongodb-src-r4.2.3 目录删除 cd /usr/local/mongodb strip mongos strip mongod strip mongo ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:6:0","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["数据库"],"content":"7.测试 cd /home/mongodb/mongodb/ mkdir -p data/db nohup /home/mongodb/mongodb/bin/mongod --dbpath /home/mongodb/mongodb/data/db \u0026 /home/mongodb/mongodb/bin/mongo show db 参考文档 https://bbs.huaweicloud.com/blogs/155007 ","date":"2021-11-05","objectID":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/:7:0","tags":["Mongo","中间件","数据库"],"title":"mongodb4.2 ARM平台编译","uri":"/mongodb4.2arm%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/"},{"categories":["Linux"],"content":"解决inode占用过多的解决方案 ","date":"2021-11-04","objectID":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:0:0","tags":["操作系统","linux"],"title":"解决inode占用过多的解决方案","uri":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Linux"],"content":"前情提要： ​ 某台服务器inode满了，很久没有处理过类似问题了，有点忘记，记录在此。 一、理解inode ​ 要理解inode，要从文件存储说起，Linux系统文件在物理上都是存储在硬盘上面的，硬盘存储里面，最小存储单位是\"扇区(Sector)\"，每个扇区存储512字节。 ​ ​ 操作系统在读取硬盘的时候不会一个一个读取扇区，这样效率很低，而是一次性连续读取多个扇区，多个扇区就组成了一个块(block)，而这种由多个扇区组成的块，就是文件存储的最小单位，块的大小一般为4KB，也就是说8个扇区组成了一个block。 ​ 文件信息存储在block中，如何找到这些block，以及怎么知道这些block存储了哪些内容，如文件的创建人、时间、大小等信息，这些信息又叫元数据，而这种存储元数据的区域就叫做inode，inode就是索引节点。 ​ 也就是说每个文件都需要记录这些元信息，也必然会占用inode，因此inode占用过多，多数是小文件太多导致。 二、查找哪里占用inode ​ 查看 / 目录 inode满了，导致服务无法正常重启，并且存在大量的僵尸进程造成内存耗尽，知道了inode占用多是文件多导致之后，那么只需要找到哪些目录下小文件过多，然后删除即可 ","date":"2021-11-04","objectID":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:0","tags":["操作系统","linux"],"title":"解决inode占用过多的解决方案","uri":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Linux"],"content":"1.查看哪个盘占用inode df -ih df -ia 两个命令均可 top ##查看异常使用进程 ","date":"2021-11-04","objectID":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:1","tags":["操作系统","linux"],"title":"解决inode占用过多的解决方案","uri":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Linux"],"content":"2.进入该挂载目录，然后通过wc -l统计哪些占用多。 ","date":"2021-11-04","objectID":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:2","tags":["操作系统","linux"],"title":"解决inode占用过多的解决方案","uri":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Linux"],"content":"3.可以看到是/var/spool/postfix/maildrop下很多小文件 ","date":"2021-11-04","objectID":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:3","tags":["操作系统","linux"],"title":"解决inode占用过多的解决方案","uri":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Linux"],"content":"4.解决办法：执行以下命令 ps -ef | egrep \"sendmail|postdrop\" | grep -v grep |xargs kill 或者 killall postdrop ​ 查到了/var/spool/postfix/maildrop目录下有大量小文件，原来是crond在执行脚本时，会将保持信息以邮件的形式发送给crond用户，而环境的postfix没有正常运行，导致邮件发送失败，都会堆积在/var/spool/postfix/maildrop/目录中，要解决该问题，一是可以启动postfix，让邮件服务正常运行.另外还可以在/etc/crontab中修改配置MAILTO=““发送为空，这样就不会堆积了。 ​ 删除占用inode的文件 find /var/spool/postfix/maildrop/ -type f |xargs rm -rf ps： ​ 建议正式环境非工作时间操作，避免影响服务器性能。 ​ 遍历查找数据盘inode占用最多的目录 find /data -xdev -printf '%h\\n' | sort | uniq -c | sort -k 1 -n ## /data 目录根据需求进行替换 ","date":"2021-11-04","objectID":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:4","tags":["操作系统","linux"],"title":"解决inode占用过多的解决方案","uri":"/%E8%A7%A3%E5%86%B3inode%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["通话"],"content":"pbx临时保存wav录音格式文件 ","date":"2021-11-03","objectID":"/pbx%E4%B8%B4%E6%97%B6%E4%BF%9D%E5%AD%98wav%E5%BD%95%E9%9F%B3%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/:0:0","tags":["呼叫中心","通话"],"title":"Pbx临时保存wav录音格式文件说明","uri":"/pbx%E4%B8%B4%E6%97%B6%E4%BF%9D%E5%AD%98wav%E5%BD%95%E9%9F%B3%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"},{"categories":["通话"],"content":"用ass合成 1.在server.conf中[server]段内添加需要wav文件的账号： thisAccountNeedWav=N00000000535,N00000001583 多个账号用，(英文逗号)隔开。 2.在server.conf中[server]段内添加wav保存的天数： deleteWavs=3 wav文件比较大，不建议保存太久。 3.reload 一下ass配置文件： (echo “Login -u 用户名 -p 密码”;sleep 1;echo “reload” ;sleep 3)|telnet localhost 7877 4.新加nginx配置文件： location /inOutTempOfWav { root /var/spool/asterisk/; index index.html index.htm; ##以下limit配置必须定义limit参数，否则不予以配置## limit_rate_after 10M; limit_rate 800k; limit_conn monitor_down 10; limit_req zone=monitor_down_1 burst=20 nodelay; } 5.reload nginx配置文件： /opt/nginx/sbin/nginx -s reload 配置完成后让前端运维或客户测试。 ","date":"2021-11-03","objectID":"/pbx%E4%B8%B4%E6%97%B6%E4%BF%9D%E5%AD%98wav%E5%BD%95%E9%9F%B3%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/:1:0","tags":["呼叫中心","通话"],"title":"Pbx临时保存wav录音格式文件说明","uri":"/pbx%E4%B8%B4%E6%97%B6%E4%BF%9D%E5%AD%98wav%E5%BD%95%E9%9F%B3%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"},{"categories":["通话"],"content":"sngrep部署文档 ","date":"2021-10-20","objectID":"/my-first-post/:0:0","tags":["呼叫中心","通话","工具"],"title":"My First Post","uri":"/my-first-post/"},{"categories":["通话"],"content":"安装包为：sngrep-1.4.7 ","date":"2021-10-20","objectID":"/my-first-post/:0:1","tags":["呼叫中心","通话","工具"],"title":"My First Post","uri":"/my-first-post/"},{"categories":["通话"],"content":"操作步骤： 建议将安装位置放置在数据盘路径 yum install -y ncurses-devel make libpcap-devel pcre-devel openssl-devel git gcc autoconf automake tar -zxvf sngrep-1.4.7.tar.gz cd sngrep-1.4.7 ./bootstrap.sh ./configure make \u0026\u0026make install 一般报错多为缺少依赖，自行百度查找依赖。yum进行安装就可以 sngrep -c ##进入抓包界面 你可以将以下标志传递给. /configure 以启用某些功能 配置标志功能 –with-openssl 添加OpenSSL支持来解析捕获的消息( 请求。 libssl ) –with-gnutls 添加GnuTLS支持来解析捕获的消息( 请求。 gnutls ) –with-pcre 在正则表达式字段中添加Perl兼容的正规表达式 支持 –enable-unicode 添加 Ncurses/unicode支持( 要求。 libncursesw5 ) –enable-ipv6 启用IPv6数据包捕获支持。 –enable-eep 启用EEP数据包发送/接收支持。 ","date":"2021-10-20","objectID":"/my-first-post/:0:2","tags":["呼叫中心","通话","工具"],"title":"My First Post","uri":"/my-first-post/"},{"categories":["通话"],"content":"sngrep基本参数 -h --help：显示帮助信息 -V --version：显示版本信息 -d --device：指定抓包的网卡 -I --input：从pacp文件中解析sip包 -O --output：输出捕获的包到pacp文件中 -c --calls：仅显示邀请消息 -r --rtp：捕获RTP数据包有效载荷捕获rtp包 -l --limit：限制捕获对话的数量 -i --icase：使大小写不敏感 -v --invert：颠倒（不太明白） -N --no-interface：不显示sngrep界面，仅捕获 -q --quiet：不要在无界面模式下打印捕获的对话框 -D --dump-config：打印活动的配置设置并退出 -f --config：从文件中读取配置 -R --rotate：达到捕获限制时轮换呼叫。 -H --eep-send：荷马sipcapture网址（udp：XXXX：XXXX） -L --eep-listen：监听封装的数据包（udp：XXXX：XXXX） -k --keyfile：RSA私钥文件解密捕获的数据包 抓取INVITE请求的包: sngrep ^INVITE 抓取REGISTER请求的包: sngrep ^REGISTER 抓取OPTIONS请求的包: sngrep ^OPTIONS 捕获端口5060上的所有SIP数据包: sngrep port 5060 使用sngrep查看来自pcap文件的SIP数据包，并使用过滤器: sngrep -I file.pcap host 192.168.1.1 and port 5060 或实时捕获，将数据包保存到新文件: sngrep -d eth0 -O save.pcap port 5060 and udp ","date":"2021-10-20","objectID":"/my-first-post/:0:3","tags":["呼叫中心","通话","工具"],"title":"My First Post","uri":"/my-first-post/"},{"categories":["通话"],"content":"快捷键 • 箭头键：在列表中移动，除上下箭头还可以使用j，k来移动光标 • 输入：显示当前或所选对话框的消息流 • 答：自动滚动到新电话，自动滚动到新的电话 • F2或S：将所选/所有对话框保存到PCAP文件，保存对话框到pacp文件 • F3或/或TAB：输入显示过滤器。该过滤器将应用于列表中的文本行，进入搜索 • F4或x：显示当前选择的对话框和其相关的一个。回到第一个SIP消息上 • F5：清除通话清单，清空通话清单 • F6或r：以原始文本显示所选对话框的消息，显示原始的sip消息 • F7或f：显示高级过滤器对话框显示高级过滤弹窗 • F9或l：如果启用，则打开/关闭地址解析 • F10或t：选择显示的列，显示或隐藏侧边sip消息栏 呼叫列表页面还能够显示两个弹窗，按f可以显示高级过滤配置 ","date":"2021-10-20","objectID":"/my-first-post/:0:4","tags":["呼叫中心","通话","工具"],"title":"My First Post","uri":"/my-first-post/"}]